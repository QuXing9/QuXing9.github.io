<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>wda error:invalid session id</title>
    <link href="/2025/08/10/wda-error-invalid-session-id/"/>
    <url>/2025/08/10/wda-error-invalid-session-id/</url>
    
    <content type="html"><![CDATA[<h1 id="wda-error-invalid-session-id"><a href="#wda-error-invalid-session-id" class="headerlink" title="wda error: invalid session id"></a>wda error: invalid session id</h1><h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p><a href="https://github.com/appium/WebDriverAgent">WebDriverAgent</a>是一个运行在ios手机端的web服务器，可用于控制ios设备，例如启动指定app，点击屏幕坐标，获取应用控件树等，该工具在ios自动化测试中常作为手机驱动使用。WebDriverAgent虽然功能齐全，被各大厂广泛使用，但bug也多，替代产品少，所以是众多测开同学逃不过的噩梦。在近期工作中，遇到一个问题：打开网页A时，正在运行测试中的设备会突然推出测试app，并报错：<code>wda.exceptions.WDAInvalidSessionIdError</code>。经过仔细分析，是wda建连session机制的特殊性所致，本篇文章对我的遇到的问题做一个分享，帮助大家排坑。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在打开网页A（这是一个控制手机设备的网页）时，正在运行测试用例的ios手机B突然退出测试app，并出现报错：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wda.exceptions.WDAInvalidSessionIdError: WDARequestError(status=110, value=&#123;&#x27;error&#x27;: &#x27;invalid session id&#x27;, &#x27;message&#x27;: &#x27;Session does not exist&#x27;&#125;)<br></code></pre></td></tr></table></figure><p>而查看ios手机的运行进程，发现wda（webdriveragent的简称）并没有退出，只是session断连了。但是为什么session会断连呢？并且session断连wda会退出测试app吗？带着这个疑问我进行了问题排查。</p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>首先说明这里的session是什么？session是指wda与测试代码在测试前通过wda的<code>/session</code>接口建立的一个session连接，其中wda是server端，测试代码是client端。有了这个session连接，我们才能调用wda的一些端口，例如截图手机，点击屏幕坐标等。为了弄明白上面两个问题，我们做了一个实验，验证了上面的第二个问题。实验代码如下：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-comment"># 通过pip3 install facebook-wda安装</span><br><span class="hljs-keyword">import</span> wda<br><br>bundle_id = <span class="hljs-string">&quot;com.tencent.xin&quot;</span><br>udid = <span class="hljs-string">&quot;xxxxx&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sessionA</span>():<br>    <span class="hljs-comment"># 使用client建立的session，微信也会退出</span><br>    <span class="hljs-comment"># session_a = wda.Client(url=&quot;http://127.0.0.1:8100&quot;).session(bundle_id)</span><br>    <span class="hljs-comment"># 使用wda.USBClient建立的session，微信会退出</span><br>    session_a = wda.USBClient(udid=udid).session(bundle_id)<br>    <span class="hljs-built_in">print</span>(session_a.session_id)<br>    session_a.app_start(bundle_id)<br>    time.sleep(<span class="hljs-number">10</span>)<br>    session_a.app_start(bundle_id)<br>    <span class="hljs-built_in">print</span>(session_a.session_id)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sessionB</span>():<br>    session_b = wda.USBClient(udid=udid).session()<br>    <span class="hljs-built_in">print</span>(session_b.session_id)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 先执行A</span><br>    sessionA()<br>    <span class="hljs-comment"># 注释掉A，再执行B</span><br>    <span class="hljs-comment"># sessionB()</span><br></code></pre></td></tr></table></figure><p>这个实验的内容是：  </p><ol><li>进程A先和wda建立session连接，并通过session启动微信应用。</li><li>进程A sleep 10秒</li><li>进程B立即与wda建立新的session连接，但不启动app。</li><li>等待进程A休眠结束，并再次启动微信app。</li></ol><p>实验结果如下：<br>进程B在创建session后，进程A立马断连，并报错<code>error: invalid session id</code>。</p><p><strong>实验结论：</strong><br>说明wda只能建立单连session，并且session断连会退出通过session拉起的app。  </p><p>确认了这个问题后，我们找到了网页A的开发同学，查看网页源码后，发现果然在打开网页A时会和手机上的wda建立新的session连接，所以导致了之前测试代码中的session失效，随即测试app退出的问题。</p><h2 id="问题拓展"><a href="#问题拓展" class="headerlink" title="问题拓展"></a>问题拓展</h2><p>经过查看wda的源码发现，session失效会退出app这个特性是通过wda里的一个变量<code>shouldTerminateApp</code>控制的，该变量默认值为<code>true</code>。在调用<code>/session</code>接口时，可以通过传递<code>capabilities</code>参数（是一个dict变量），指定<code>shouldTerminateApp</code>项为<code>false</code>解决。但这样虽然app不退出，之前的session连接也是会失效的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>fix: pip is looking at multiple versions of ctcli to determine which version is compatible with other requirements.</title>
    <link href="/2025/07/27/pipinstall%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2025/07/27/pipinstall%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="pip-install依赖冲突-pip-is-looking-at-multiple-versions-of-ctcli-to-determine-which-version-is-compatible-with-other-requirements"><a href="#pip-install依赖冲突-pip-is-looking-at-multiple-versions-of-ctcli-to-determine-which-version-is-compatible-with-other-requirements" class="headerlink" title="pip install依赖冲突: pip is looking at multiple versions of ctcli to determine which version is compatible with other requirements."></a>pip install依赖冲突: pip is looking at multiple versions of ctcli to determine which version is compatible with other requirements.</h1><h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>遇到一个超级离谱的pip安装包问题，源于pip安装包时的依赖冲突，但是报错信息最终与解决方案却毫无关系，浪费了好几小时才解决这个问题。借此文章复盘下问题并梳理循环安装依赖的原因及解决方案。遇到的具体问题是：使用<code>pip install xxx</code>安装包时，pip循环下载解析安装包的历史版本，无法正常退出。错误信息如下所示：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">INFO: pip is looking at multiple versions of ctcli to determine which version is compatible with other requirements. This could take a while.<br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>先说解决方案：需要指定包含所有安装依赖的镜像源。（注意：这里的解决方案不是这个报错的唯一解决方案，仅供参考）<br>出现问题时我的安装指令是，这里<code>-i</code>指定的是公司内部镜像源，xxx也是内部包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip3 install xxx -i https://mirrors.tencent.com/xxxx<br></code></pre></td></tr></table></figure><p>安装报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">INFO: pip is looking at multiple versions of ctcli to determine which version is compatible with other requirements. This could take a while.<br></code></pre></td></tr></table></figure><p>出现报错的原因是内部镜像源没有xxx安装包所需要的依赖库<code>argcomplete</code>，因此出现循环下载历史包的现象。解决方案为：加上extra-index-url参数，指定外部镜像源，因为外部镜像源中包含<code>argcomplete</code>库:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip3 install xxx -i https://mirrors.tencent.com/xxxx --extra-index-url https://mirrors.tencent.com/pypi/simple/<br></code></pre></td></tr></table></figure><p>这也就是这个问题巨坑的地方，安装依赖包没有在源中，但是pip却不提示未找到安装包，而是会循环下载旧版本，直至找到一个满足所有依赖库的历史版本，</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>借鉴<a href="https://pip.pypa.io/en/stable/topics/dependency-resolution/">官方文档</a>，在使用<code>pip install</code>安装包时，会首先解析安装包的依赖文件，如果依赖文件不满足或有冲突，则会回退历史版本持续下载，直到找到一个不冲突的版本。<br>例如，使用<code>pip install tea</code>安装<code>tea</code>库，包含三个依赖文件:<code>hot-water</code>,<code>spoon</code>,<code>cup</code>。  </p><ol><li>pip首先会获取<code>tea</code>库的最新版本，并解析<code>tea</code>库的依赖文件，得到<code>hot-water</code>,<code>spoon</code>,<code>cup</code>。</li><li>依次对<code>hot-water</code>,<code>spoon</code>,<code>cup</code>三个库重复第一步骤，得到它们的最新版本及依赖库版本。</li><li>pip注意到<code>spoon</code>和<code>cup</code>的版本不兼容，则会会退<code>cup</code>版本，找到一个和<code>spoon</code>兼容的版本。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install tea<br>Collecting tea<br>  Downloading tea-1.9.8-py2.py3-none-any.whl (346 kB)<br>    |████████████████████████████████| 346 kB 10.4 MB/s<br>Collecting spoon==2.27.0<br>  Downloading spoon-2.27.0-py2.py3-none-any.whl (312 kB)<br>    |████████████████████████████████| 312 kB 19.2 MB/s<br>Collecting cup&gt;=1.6.0<br>  Downloading cup-3.22.0-py2.py3-none-any.whl (397 kB)<br>    |████████████████████████████████| 397 kB 28.2 MB/s<br>INFO: pip is looking at multiple versions of this package to determine<br>which version is compatible with other requirements.<br>This could take a while.<br>  Downloading cup-3.21.0-py2.py3-none-any.whl (395 kB)<br>    |████████████████████████████████| 395 kB 27.0 MB/s<br>  Downloading cup-3.20.0-py2.py3-none-any.whl (394 kB)<br>    |████████████████████████████████| 394 kB 24.4 MB/s<br>  Downloading cup-3.19.1-py2.py3-none-any.whl (394 kB)<br>    |████████████████████████████████| 394 kB 21.3 MB/s<br>  Downloading cup-3.19.0-py2.py3-none-any.whl (394 kB)<br>    |████████████████████████████████| 394 kB 26.2 MB/s<br>  Downloading cup-3.18.0-py2.py3-none-any.whl (393 kB)<br>    |████████████████████████████████| 393 kB 22.1 MB/s<br>  Downloading cup-3.17.0-py2.py3-none-any.whl (382 kB)<br>    |████████████████████████████████| 382 kB 23.8 MB/s<br>  Downloading cup-3.16.0-py2.py3-none-any.whl (376 kB)<br>    |████████████████████████████████| 376 kB 27.5 MB/s<br>  Downloading cup-3.15.1-py2.py3-none-any.whl (385 kB)<br>    |████████████████████████████████| 385 kB 30.4 MB/s<br>INFO: pip is looking at multiple versions of this package to determine<br>which version is compatible with other requirements.<br>This could take a while.<br>  Downloading cup-3.15.0-py2.py3-none-any.whl (378 kB)<br>    |████████████████████████████████| 378 kB 21.4 MB/s<br>  Downloading cup-3.14.0-py2.py3-none-any.whl (372 kB)<br>    |████████████████████████████████| 372 kB 21.1 MB/s<br></code></pre></td></tr></table></figure></li><li>pip会持续回退，不知道会回退多少次，直到找到一个没有冲突的版本。。</li></ol><p>持续下载历史安装包很多次，可能会等很久，解决方法有以下几个：   </p><ol><li>使用<code>ctrl+c</code>手动暂停下载。（这并不解决问题） </li><li>指定冲突依赖库的版本。如果未能安装成功，pip将抛出错误信息指明哪些安装包冲突，有利于开发者修复。(博主最终也是通过这个方法发现冲突的依赖库) <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install tea &quot;cup &gt;= 3.13&quot;<br></code></pre></td></tr></table></figure></li><li>在安装包的依赖文件中处理好依赖，指明依赖库的版本，避免在安装时发生依赖冲突。可使用<a href="https://github.com/jazzband/pip-tools/">pip-tools</a>工具生成合格的<code>requirement.txt</code>文件。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install pip-tools<br>python -m piptools compile<br></code></pre></td></tr></table></figure></li></ol><h2 id="问题延展"><a href="#问题延展" class="headerlink" title="问题延展"></a>问题延展</h2><p>在上面的步骤二，找到了冲突文件后，应该怎么解决呢？例如类似下面的报错信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">python -m pip install package_coffee==0.44.1 package_tea==4.3.0</span><br>[regular pip output]<br>ERROR: Cannot install package_coffee==0.44.1 and package_tea==4.3.0 because these package versions have conflicting dependencies.<br>The conflict is caused by:<br>    package_coffee 0.44.1 depends on package_water&lt;3.0.0,&gt;=2.4.2<br>    package_tea 4.3.0 depends on package_water==2.3.1<br></code></pre></td></tr></table></figure><p>可以看到在安装<code>package_coffee</code>和<code>package_tea</code>时指定了版本，但是报错<code>package_water</code>依赖项有版本冲突。这时我们只能寻找两个依赖库都不对<code>package_water</code>冲突的版本。寻找方法为：<br>放宽安装包的版本，例如<code>package_coffee&gt;0.44</code>,<code>package_tea&gt;4.0.0</code>，这时pip将自动寻找同时满足<code>package_water</code>的安装包版本。</p><ul><li>package_coffee 0.44.1, which depends on package_water 2.6.1</li><li>package_tea 4.4.3 which also depends on package_water 2.6.1</li></ul><p>这时我们再执行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install package_coffee==0.44.1 package_tea==4.4.3<br></code></pre></td></tr></table></figure><p>如果你想优先指定某个安装库的版本，可以这样执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install package_coffee==0.44.1 package_tea<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
